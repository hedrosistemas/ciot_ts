// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "hg/proto/v1/hg_tcp.proto" (package "Hg", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { OtaStatus } from "../../../ciot/proto/v2/ota";
import { DfuStatus } from "../../../ciot/proto/v2/dfu";
import { NtpStatus } from "../../../ciot/proto/v2/ntp";
import { SysStatus } from "../../../ciot/proto/v2/sys";
import { Status } from "../../../ciot/proto/v2/ciot";
import { SysInfo } from "../../../ciot/proto/v2/sys";
import { WifiStatus } from "../../../ciot/proto/v2/wifi";
import { WifiInfo } from "../../../ciot/proto/v2/wifi";
import { TcpStatus } from "../../../ciot/proto/v2/tcp";
import { TcpInfo } from "../../../ciot/proto/v2/tcp";
import { MqttClientCfg } from "../../../ciot/proto/v2/mqtt_client";
import { NtpCfg } from "../../../ciot/proto/v2/ntp";
import { BleCfg } from "../../../ciot/proto/v2/ble";
/**
 * HG TCP Module available for provisioning message
 *
 * @generated from protobuf message Hg.TcpProvAvailable
 */
export interface TcpProvAvailable {
    /**
     * @generated from protobuf field: uint64 t = 1
     */
    t: bigint; // Message timestamp
    /**
     * @generated from protobuf field: Hg.TcpProvState state = 2
     */
    state: TcpProvState; // HG prov state
    /**
     * @generated from protobuf field: bytes app_ver = 3
     */
    appVer: Uint8Array; // HG application version
    /**
     * @generated from protobuf field: string hw_ver = 4
     */
    hwVer: string; // HG hardware version
    /**
     * @generated from protobuf field: string hw_type = 5
     */
    hwType: string; // HG hardware type
    /**
     * @generated from protobuf field: Hg.HardwareMacs hw_macs = 6
     */
    hwMacs?: HardwareMacs; // HG Hardware mac addresses
    /**
     * @generated from protobuf field: int32 tries = 7
     */
    tries: number; // HG prov tries count
    /**
     * @generated from protobuf field: Hg.TcpProvError err = 8
     */
    err: TcpProvError; // HG prov error code
    /**
     * @generated from protobuf field: uint32 sn = 9
     */
    sn: number; // HG device serial number
}
/**
 * HG TCP Module provisioning request
 *
 * @generated from protobuf message Hg.TcpProvReq
 */
export interface TcpProvReq {
    /**
     * @generated from protobuf field: uint64 t = 1
     */
    t: bigint; // Timestamp
    /**
     * @generated from protobuf field: Ciot.BleCfg ble = 2
     */
    ble?: BleCfg; // Bluetooth configuration
    /**
     * @generated from protobuf field: Ciot.NtpCfg ntp = 3
     */
    ntp?: NtpCfg; // NTP configuration
    /**
     * @generated from protobuf field: Ciot.MqttClientCfg mqtt = 4
     */
    mqtt?: MqttClientCfg; // MQTT configuration
    /**
     * @generated from protobuf field: string mqtt_network = 5
     */
    mqttNetwork: string; // MQTT network topic
    /**
     * @generated from protobuf field: string org_id = 6
     */
    orgId: string; // Organization ID
    /**
     * @generated from protobuf field: uint32 sn = 7
     */
    sn: number; // Gateway Serial number
}
/**
 * HG TCP Module data saved on device flash memory
 *
 * @generated from protobuf message Hg.TcpPersistentData
 */
export interface TcpPersistentData {
    /**
     * @generated from protobuf field: string mqtt_network = 1
     */
    mqttNetwork: string; // MQTT network topic
    /**
     * @generated from protobuf field: string org_id = 2
     */
    orgId: string; // Device organization ID
}
/**
 * @generated from protobuf message Hg.HardwareMacs
 */
export interface HardwareMacs {
    /**
     * @generated from protobuf field: bytes ble = 1
     */
    ble: Uint8Array; // BLE module mac address
    /**
     * @generated from protobuf field: bytes tcp = 2
     */
    tcp: Uint8Array; // TCP module mac address
}
/**
 * @generated from protobuf message Hg.EthHealth
 */
export interface EthHealth {
    /**
     * @generated from protobuf field: Ciot.TcpInfo info = 1
     */
    info?: TcpInfo;
    /**
     * @generated from protobuf field: Ciot.TcpStatus status = 2
     */
    status?: TcpStatus;
}
/**
 * @generated from protobuf message Hg.WifiHealth
 */
export interface WifiHealth {
    /**
     * @generated from protobuf field: Ciot.WifiInfo info = 1
     */
    info?: WifiInfo;
    /**
     * @generated from protobuf field: Ciot.WifiStatus status = 2
     */
    status?: WifiStatus;
}
/**
 * HG TCP Module health message
 *
 * @generated from protobuf message Hg.TcpHealth
 */
export interface TcpHealth {
    /**
     * @generated from protobuf field: uint64 t = 1
     */
    t: bigint; // Message timestamp
    /**
     * @generated from protobuf field: uint32 sn = 2
     */
    sn: number; // Serial number
    /**
     * @generated from protobuf field: Hg.HardwareMacs hw_macs = 3
     */
    hwMacs?: HardwareMacs; // Hardware mac addresses
    /**
     * @generated from protobuf field: string org_id = 4
     */
    orgId: string; // Organization ID
    /**
     * @generated from protobuf field: Ciot.SysInfo info = 5
     */
    info?: SysInfo; // Device system information
    /**
     * @generated from protobuf field: Hg.TcpState state = 6
     */
    state: TcpState; // Gateway state
    /**
     * @generated from protobuf field: Ciot.Status ciot = 7
     */
    ciot?: Status; // Ciot status data
    /**
     * @generated from protobuf field: Ciot.SysStatus sys = 8
     */
    sys?: SysStatus; // System status data
    /**
     * @generated from protobuf field: Hg.EthHealth eth = 9
     */
    eth?: EthHealth; // Ethernet status data
    /**
     * @generated from protobuf field: Hg.WifiHealth wifi_ap = 10
     */
    wifiAp?: WifiHealth; // WiFi access point status data
    /**
     * @generated from protobuf field: Hg.WifiHealth wifi_sta = 11
     */
    wifiSta?: WifiHealth; // WiFi station status data
    /**
     * @generated from protobuf field: Ciot.NtpStatus ntp = 12
     */
    ntp?: NtpStatus; // NTP status data
    /**
     * @generated from protobuf field: Ciot.DfuStatus dfu = 13
     */
    dfu?: DfuStatus; // DFU status data
    /**
     * @generated from protobuf field: Ciot.OtaStatus ota = 14
     */
    ota?: OtaStatus; // OTA status data
}
/**
 * HG TCP Module interfaces ids
 *
 * @generated from protobuf enum Hg.TcpIfaceId
 */
export enum TcpIfaceId {
    /**
     * CIoT interface
     *
     * @generated from protobuf enum value: TCP_IFACE_ID_CIOT = 0;
     */
    CIOT = 0,
    /**
     * System interface
     *
     * @generated from protobuf enum value: TCP_IFACE_ID_SYS = 1;
     */
    SYS = 1,
    /**
     * Ethernet interface
     *
     * @generated from protobuf enum value: TCP_IFACE_ID_ETH = 2;
     */
    ETH = 2,
    /**
     * WiFi access point interface
     *
     * @generated from protobuf enum value: TCP_IFACE_ID_WIFI_AP = 3;
     */
    WIFI_AP = 3,
    /**
     * HTTP Server interface
     *
     * @generated from protobuf enum value: TCP_IFACE_ID_HTTP_SERVER = 4;
     */
    HTTP_SERVER = 4,
    /**
     * WiFi station interface
     *
     * @generated from protobuf enum value: TCP_IFACE_ID_WIFI_STA = 5;
     */
    WIFI_STA = 5,
    /**
     * NTP interface
     *
     * @generated from protobuf enum value: TCP_IFACE_ID_NTP = 6;
     */
    NTP = 6,
    /**
     * MQTT client interface
     *
     * @generated from protobuf enum value: TCP_IFACE_ID_MQTT_CLIENT = 7;
     */
    MQTT_CLIENT = 7,
    /**
     * OTA interface
     *
     * @generated from protobuf enum value: TCP_IFACE_ID_OTA = 8;
     */
    OTA = 8,
    /**
     * UART interface
     *
     * @generated from protobuf enum value: TCP_IFACE_ID_UART = 9;
     */
    UART = 9,
    /**
     * Ble Scanner interface
     *
     * @generated from protobuf enum value: TCP_IFACE_ID_BLE_SCN = 10;
     */
    BLE_SCN = 10,
    /**
     * RS485 interface
     *
     * @generated from protobuf enum value: TCP_IFACE_ID_RS485 = 11;
     */
    RS485 = 11,
    /**
     * Modbus server interface
     *
     * @generated from protobuf enum value: TCP_IFACE_ID_MBUS_SERVER = 12;
     */
    MBUS_SERVER = 12,
    /**
     * CIoT interface count
     *
     * @generated from protobuf enum value: TCP_IFACE_ID_COUNT = 13;
     */
    COUNT = 13,
    /**
     * Gateway TCP interface
     *
     * @generated from protobuf enum value: TCP_IFACE_ID_HG_TCP = 99;
     */
    HG_TCP = 99
}
/**
 * HG TCP Module states
 *
 * @generated from protobuf enum Hg.TcpState
 */
export enum TcpState {
    /**
     * HG TCP state idle
     *
     * @generated from protobuf enum value: TCP_STATE_IDLE = 0;
     */
    IDLE = 0,
    /**
     * HG TCP state started
     *
     * @generated from protobuf enum value: TCP_STATE_STARTED = 1;
     */
    STARTED = 1,
    /**
     * HG TCP state provisioned
     *
     * @generated from protobuf enum value: TCP_STATE_PROVISIONED = 2;
     */
    PROVISIONED = 2
}
/**
 * HG TCP Module prov states
 *
 * @generated from protobuf enum Hg.TcpProvState
 */
export enum TcpProvState {
    /**
     * HG TCP prov state idle
     *
     * @generated from protobuf enum value: TCP_PROV_STATE_IDLE = 0;
     */
    IDLE = 0,
    /**
     * HG TCP prov state in progress
     *
     * @generated from protobuf enum value: TCP_PROV_STATE_IN_PROGRESS = 1;
     */
    IN_PROGRESS = 1,
    /**
     * HG TCP prov state completed
     *
     * @generated from protobuf enum value: TCP_PROV_STATE_COMPLETED = 2;
     */
    COMPLETED = 2
}
/**
 * HG TCP Module prov error codes
 *
 * @generated from protobuf enum Hg.TcpProvError
 */
export enum TcpProvError {
    /**
     * Prov OK
     *
     * @generated from protobuf enum value: TCP_PROV_ERROR_OK = 0;
     */
    OK = 0,
    /**
     * BLE module error
     *
     * @generated from protobuf enum value: TCP_PROV_ERROR_BLE = 1;
     */
    BLE = 1,
    /**
     * NTP sync error
     *
     * @generated from protobuf enum value: TCP_PROV_ERROR_NTP = 2;
     */
    NTP = 2,
    /**
     * MQTT connection error
     *
     * @generated from protobuf enum value: TCP_PROV_ERROR_MQTT = 3;
     */
    MQTT = 3,
    /**
     * HG TCP Prov manager is busy
     *
     * @generated from protobuf enum value: TCP_PROV_ERROR_BUSY = 4;
     */
    BUSY = 4,
    /**
     * Invalid BLE configuration
     *
     * @generated from protobuf enum value: TCP_PROV_ERROR_INVALID_BLE = 5;
     */
    INVALID_BLE = 5,
    /**
     * Invalid NTP configuration
     *
     * @generated from protobuf enum value: TCP_PROV_ERROR_INVALID_NTP = 6;
     */
    INVALID_NTP = 6,
    /**
     * Invalid MQTT configuration
     *
     * @generated from protobuf enum value: TCP_PROV_ERROR_INVALID_MQTT = 7;
     */
    INVALID_MQTT = 7,
    /**
     * Invalid Organization ID
     *
     * @generated from protobuf enum value: TCP_PROV_ERROR_INVALID_ORG_ID = 8;
     */
    INVALID_ORG_ID = 8,
    /**
     * Invalid MQTT Network
     *
     * @generated from protobuf enum value: TCP_PROV_ERROR_INVALID_MQTT_NETWORK = 9;
     */
    INVALID_MQTT_NETWORK = 9
}
/**
 * Enum representing different types of HG TCP Module reset
 *
 * @generated from protobuf enum Hg.TcpResetType
 */
export enum TcpResetType {
    /**
     * Unknown reset type.
     *
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Soft reset.
     *
     * @generated from protobuf enum value: SOFT = 1;
     */
    SOFT = 1,
    /**
     * Provisioning reset.
     *
     * @generated from protobuf enum value: PROV = 2;
     */
    PROV = 2,
    /**
     * Reset all settings.
     *
     * @generated from protobuf enum value: ALL = 3;
     */
    ALL = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class TcpProvAvailable$Type extends MessageType<TcpProvAvailable> {
    constructor() {
        super("Hg.TcpProvAvailable", [
            { no: 1, name: "t", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "state", kind: "enum", T: () => ["Hg.TcpProvState", TcpProvState, "TCP_PROV_STATE_"] },
            { no: 3, name: "app_ver", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "hw_ver", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "hw_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "hw_macs", kind: "message", T: () => HardwareMacs },
            { no: 7, name: "tries", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "err", kind: "enum", T: () => ["Hg.TcpProvError", TcpProvError, "TCP_PROV_ERROR_"] },
            { no: 9, name: "sn", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TcpProvAvailable>): TcpProvAvailable {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.t = 0n;
        message.state = 0;
        message.appVer = new Uint8Array(0);
        message.hwVer = "";
        message.hwType = "";
        message.tries = 0;
        message.err = 0;
        message.sn = 0;
        if (value !== undefined)
            reflectionMergePartial<TcpProvAvailable>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TcpProvAvailable): TcpProvAvailable {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 t */ 1:
                    message.t = reader.uint64().toBigInt();
                    break;
                case /* Hg.TcpProvState state */ 2:
                    message.state = reader.int32();
                    break;
                case /* bytes app_ver */ 3:
                    message.appVer = reader.bytes();
                    break;
                case /* string hw_ver */ 4:
                    message.hwVer = reader.string();
                    break;
                case /* string hw_type */ 5:
                    message.hwType = reader.string();
                    break;
                case /* Hg.HardwareMacs hw_macs */ 6:
                    message.hwMacs = HardwareMacs.internalBinaryRead(reader, reader.uint32(), options, message.hwMacs);
                    break;
                case /* int32 tries */ 7:
                    message.tries = reader.int32();
                    break;
                case /* Hg.TcpProvError err */ 8:
                    message.err = reader.int32();
                    break;
                case /* uint32 sn */ 9:
                    message.sn = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TcpProvAvailable, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 t = 1; */
        if (message.t !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.t);
        /* Hg.TcpProvState state = 2; */
        if (message.state !== 0)
            writer.tag(2, WireType.Varint).int32(message.state);
        /* bytes app_ver = 3; */
        if (message.appVer.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.appVer);
        /* string hw_ver = 4; */
        if (message.hwVer !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.hwVer);
        /* string hw_type = 5; */
        if (message.hwType !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.hwType);
        /* Hg.HardwareMacs hw_macs = 6; */
        if (message.hwMacs)
            HardwareMacs.internalBinaryWrite(message.hwMacs, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* int32 tries = 7; */
        if (message.tries !== 0)
            writer.tag(7, WireType.Varint).int32(message.tries);
        /* Hg.TcpProvError err = 8; */
        if (message.err !== 0)
            writer.tag(8, WireType.Varint).int32(message.err);
        /* uint32 sn = 9; */
        if (message.sn !== 0)
            writer.tag(9, WireType.Varint).uint32(message.sn);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Hg.TcpProvAvailable
 */
export const TcpProvAvailable = new TcpProvAvailable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TcpProvReq$Type extends MessageType<TcpProvReq> {
    constructor() {
        super("Hg.TcpProvReq", [
            { no: 1, name: "t", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "ble", kind: "message", T: () => BleCfg },
            { no: 3, name: "ntp", kind: "message", T: () => NtpCfg },
            { no: 4, name: "mqtt", kind: "message", T: () => MqttClientCfg },
            { no: 5, name: "mqtt_network", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "org_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "sn", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TcpProvReq>): TcpProvReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.t = 0n;
        message.mqttNetwork = "";
        message.orgId = "";
        message.sn = 0;
        if (value !== undefined)
            reflectionMergePartial<TcpProvReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TcpProvReq): TcpProvReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 t */ 1:
                    message.t = reader.uint64().toBigInt();
                    break;
                case /* Ciot.BleCfg ble */ 2:
                    message.ble = BleCfg.internalBinaryRead(reader, reader.uint32(), options, message.ble);
                    break;
                case /* Ciot.NtpCfg ntp */ 3:
                    message.ntp = NtpCfg.internalBinaryRead(reader, reader.uint32(), options, message.ntp);
                    break;
                case /* Ciot.MqttClientCfg mqtt */ 4:
                    message.mqtt = MqttClientCfg.internalBinaryRead(reader, reader.uint32(), options, message.mqtt);
                    break;
                case /* string mqtt_network */ 5:
                    message.mqttNetwork = reader.string();
                    break;
                case /* string org_id */ 6:
                    message.orgId = reader.string();
                    break;
                case /* uint32 sn */ 7:
                    message.sn = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TcpProvReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 t = 1; */
        if (message.t !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.t);
        /* Ciot.BleCfg ble = 2; */
        if (message.ble)
            BleCfg.internalBinaryWrite(message.ble, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.NtpCfg ntp = 3; */
        if (message.ntp)
            NtpCfg.internalBinaryWrite(message.ntp, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.MqttClientCfg mqtt = 4; */
        if (message.mqtt)
            MqttClientCfg.internalBinaryWrite(message.mqtt, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string mqtt_network = 5; */
        if (message.mqttNetwork !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.mqttNetwork);
        /* string org_id = 6; */
        if (message.orgId !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.orgId);
        /* uint32 sn = 7; */
        if (message.sn !== 0)
            writer.tag(7, WireType.Varint).uint32(message.sn);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Hg.TcpProvReq
 */
export const TcpProvReq = new TcpProvReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TcpPersistentData$Type extends MessageType<TcpPersistentData> {
    constructor() {
        super("Hg.TcpPersistentData", [
            { no: 1, name: "mqtt_network", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "org_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TcpPersistentData>): TcpPersistentData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mqttNetwork = "";
        message.orgId = "";
        if (value !== undefined)
            reflectionMergePartial<TcpPersistentData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TcpPersistentData): TcpPersistentData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string mqtt_network */ 1:
                    message.mqttNetwork = reader.string();
                    break;
                case /* string org_id */ 2:
                    message.orgId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TcpPersistentData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string mqtt_network = 1; */
        if (message.mqttNetwork !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.mqttNetwork);
        /* string org_id = 2; */
        if (message.orgId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.orgId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Hg.TcpPersistentData
 */
export const TcpPersistentData = new TcpPersistentData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HardwareMacs$Type extends MessageType<HardwareMacs> {
    constructor() {
        super("Hg.HardwareMacs", [
            { no: 1, name: "ble", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "tcp", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<HardwareMacs>): HardwareMacs {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ble = new Uint8Array(0);
        message.tcp = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<HardwareMacs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HardwareMacs): HardwareMacs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes ble */ 1:
                    message.ble = reader.bytes();
                    break;
                case /* bytes tcp */ 2:
                    message.tcp = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HardwareMacs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes ble = 1; */
        if (message.ble.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.ble);
        /* bytes tcp = 2; */
        if (message.tcp.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.tcp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Hg.HardwareMacs
 */
export const HardwareMacs = new HardwareMacs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EthHealth$Type extends MessageType<EthHealth> {
    constructor() {
        super("Hg.EthHealth", [
            { no: 1, name: "info", kind: "message", T: () => TcpInfo },
            { no: 2, name: "status", kind: "message", T: () => TcpStatus }
        ]);
    }
    create(value?: PartialMessage<EthHealth>): EthHealth {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<EthHealth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EthHealth): EthHealth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Ciot.TcpInfo info */ 1:
                    message.info = TcpInfo.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                case /* Ciot.TcpStatus status */ 2:
                    message.status = TcpStatus.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EthHealth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Ciot.TcpInfo info = 1; */
        if (message.info)
            TcpInfo.internalBinaryWrite(message.info, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.TcpStatus status = 2; */
        if (message.status)
            TcpStatus.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Hg.EthHealth
 */
export const EthHealth = new EthHealth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WifiHealth$Type extends MessageType<WifiHealth> {
    constructor() {
        super("Hg.WifiHealth", [
            { no: 1, name: "info", kind: "message", T: () => WifiInfo },
            { no: 2, name: "status", kind: "message", T: () => WifiStatus }
        ]);
    }
    create(value?: PartialMessage<WifiHealth>): WifiHealth {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<WifiHealth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WifiHealth): WifiHealth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Ciot.WifiInfo info */ 1:
                    message.info = WifiInfo.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                case /* Ciot.WifiStatus status */ 2:
                    message.status = WifiStatus.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WifiHealth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Ciot.WifiInfo info = 1; */
        if (message.info)
            WifiInfo.internalBinaryWrite(message.info, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.WifiStatus status = 2; */
        if (message.status)
            WifiStatus.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Hg.WifiHealth
 */
export const WifiHealth = new WifiHealth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TcpHealth$Type extends MessageType<TcpHealth> {
    constructor() {
        super("Hg.TcpHealth", [
            { no: 1, name: "t", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "sn", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "hw_macs", kind: "message", T: () => HardwareMacs },
            { no: 4, name: "org_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "info", kind: "message", T: () => SysInfo },
            { no: 6, name: "state", kind: "enum", T: () => ["Hg.TcpState", TcpState, "TCP_STATE_"] },
            { no: 7, name: "ciot", kind: "message", T: () => Status },
            { no: 8, name: "sys", kind: "message", T: () => SysStatus },
            { no: 9, name: "eth", kind: "message", T: () => EthHealth },
            { no: 10, name: "wifi_ap", kind: "message", T: () => WifiHealth },
            { no: 11, name: "wifi_sta", kind: "message", T: () => WifiHealth },
            { no: 12, name: "ntp", kind: "message", T: () => NtpStatus },
            { no: 13, name: "dfu", kind: "message", T: () => DfuStatus },
            { no: 14, name: "ota", kind: "message", T: () => OtaStatus }
        ]);
    }
    create(value?: PartialMessage<TcpHealth>): TcpHealth {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.t = 0n;
        message.sn = 0;
        message.orgId = "";
        message.state = 0;
        if (value !== undefined)
            reflectionMergePartial<TcpHealth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TcpHealth): TcpHealth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 t */ 1:
                    message.t = reader.uint64().toBigInt();
                    break;
                case /* uint32 sn */ 2:
                    message.sn = reader.uint32();
                    break;
                case /* Hg.HardwareMacs hw_macs */ 3:
                    message.hwMacs = HardwareMacs.internalBinaryRead(reader, reader.uint32(), options, message.hwMacs);
                    break;
                case /* string org_id */ 4:
                    message.orgId = reader.string();
                    break;
                case /* Ciot.SysInfo info */ 5:
                    message.info = SysInfo.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                case /* Hg.TcpState state */ 6:
                    message.state = reader.int32();
                    break;
                case /* Ciot.Status ciot */ 7:
                    message.ciot = Status.internalBinaryRead(reader, reader.uint32(), options, message.ciot);
                    break;
                case /* Ciot.SysStatus sys */ 8:
                    message.sys = SysStatus.internalBinaryRead(reader, reader.uint32(), options, message.sys);
                    break;
                case /* Hg.EthHealth eth */ 9:
                    message.eth = EthHealth.internalBinaryRead(reader, reader.uint32(), options, message.eth);
                    break;
                case /* Hg.WifiHealth wifi_ap */ 10:
                    message.wifiAp = WifiHealth.internalBinaryRead(reader, reader.uint32(), options, message.wifiAp);
                    break;
                case /* Hg.WifiHealth wifi_sta */ 11:
                    message.wifiSta = WifiHealth.internalBinaryRead(reader, reader.uint32(), options, message.wifiSta);
                    break;
                case /* Ciot.NtpStatus ntp */ 12:
                    message.ntp = NtpStatus.internalBinaryRead(reader, reader.uint32(), options, message.ntp);
                    break;
                case /* Ciot.DfuStatus dfu */ 13:
                    message.dfu = DfuStatus.internalBinaryRead(reader, reader.uint32(), options, message.dfu);
                    break;
                case /* Ciot.OtaStatus ota */ 14:
                    message.ota = OtaStatus.internalBinaryRead(reader, reader.uint32(), options, message.ota);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TcpHealth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 t = 1; */
        if (message.t !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.t);
        /* uint32 sn = 2; */
        if (message.sn !== 0)
            writer.tag(2, WireType.Varint).uint32(message.sn);
        /* Hg.HardwareMacs hw_macs = 3; */
        if (message.hwMacs)
            HardwareMacs.internalBinaryWrite(message.hwMacs, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string org_id = 4; */
        if (message.orgId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.orgId);
        /* Ciot.SysInfo info = 5; */
        if (message.info)
            SysInfo.internalBinaryWrite(message.info, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* Hg.TcpState state = 6; */
        if (message.state !== 0)
            writer.tag(6, WireType.Varint).int32(message.state);
        /* Ciot.Status ciot = 7; */
        if (message.ciot)
            Status.internalBinaryWrite(message.ciot, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.SysStatus sys = 8; */
        if (message.sys)
            SysStatus.internalBinaryWrite(message.sys, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* Hg.EthHealth eth = 9; */
        if (message.eth)
            EthHealth.internalBinaryWrite(message.eth, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* Hg.WifiHealth wifi_ap = 10; */
        if (message.wifiAp)
            WifiHealth.internalBinaryWrite(message.wifiAp, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* Hg.WifiHealth wifi_sta = 11; */
        if (message.wifiSta)
            WifiHealth.internalBinaryWrite(message.wifiSta, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.NtpStatus ntp = 12; */
        if (message.ntp)
            NtpStatus.internalBinaryWrite(message.ntp, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.DfuStatus dfu = 13; */
        if (message.dfu)
            DfuStatus.internalBinaryWrite(message.dfu, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* Ciot.OtaStatus ota = 14; */
        if (message.ota)
            OtaStatus.internalBinaryWrite(message.ota, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Hg.TcpHealth
 */
export const TcpHealth = new TcpHealth$Type();
